# -*- coding: utf-8 -*-
"""AMP APP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hk3E-aKuD1AVyejeuUcq9iimabnIwVrt
"""

from datetime import datetime

def compute_age(install_year: int, current_year: int = None) -> float:
    """
    Compute the age of an asset in years.
    """
    if current_year is None:
        current_year = datetime.now().year

    if install_year is None:
        return None

    return max(0, current_year - install_year)

import math

def weibull_failure_probability(age: float, eta: float, k: float) -> float:
    """
    Compute Weibull probability of failure at a given age.
    age: asset age in years
    eta: scale parameter (characteristic life)
    k: shape parameter
    """
    if age is None or eta is None or k is None:
        return None

    if age < 0:
        return 0.0

    return 1 - math.exp(-((age / eta) ** k))

def condition_class_from_probability(p_fail: float) -> int:
    """
    Convert Weibull probability of failure into a condition class (1–5).
    """
    if p_fail is None:
        return None

    if p_fail < 0.20:
        return 1
    elif p_fail < 0.40:
        return 2
    elif p_fail < 0.60:
        return 3
    elif p_fail < 0.80:
        return 4
    else:
        return 5

def replacement_cost(length_m: float, unit_cost_per_m: float) -> float:
    """
    Compute replacement or rehabilitation cost for a road segment.
    """
    if length_m is None or unit_cost_per_m is None:
        return None

    return length_m * unit_cost_per_m

def compute_road_asset_metrics(
    install_year: int,
    length_m: float,
    unit_cost_per_m: float,
    eta: float,
    k: float,
    current_year: int = None
):
    """
    Compute all lifecycle metrics for a road segment.
    Returns a dictionary with age, probability of failure,
    condition class, and replacement cost.
    """

    age = compute_age(install_year, current_year)
    p_fail = weibull_failure_probability(age, eta, k)
    condition = condition_class_from_probability(p_fail)
    cost = replacement_cost(length_m, unit_cost_per_m)

    return {
        "age_years": age,
        "prob_failure_now": p_fail,
        "condition_class": condition,
        "replacement_cost": cost
    }

def classify_road(row):
    t = str(row["ROAD_ELEMENT_TYPE"]).upper()

    if "RAMP" in t:
        return "ARTERIAL"
    if "HIGHWAY" in t:
        return "ARTERIAL"
    if "SERVICE" in t:
        return "COLLECTOR"
    if "ROAD" in t:
        return "LOCAL"

    return "LOCAL"  # fallback

import geopandas as gpd

# Path to your downloaded ORN .gdb folder
gdb_path = r"/content/drive/MyDrive/Non_Sensitive.gdb"

# ORN layer name (the main road network layer)
layer_name = "ORN_ROAD_NET_ELEMENT"

roads = gpd.read_file(gdb_path, layer=layer_name)



roads.columns

import pandas as pd

# Convert CREATION_DATE to datetime
roads["CREATION_DATE"] = pd.to_datetime(roads["CREATION_DATE"], errors="coerce")

# Extract install year
roads["install_year"] = roads["CREATION_DATE"].dt.year
roads["install_year"] = roads["install_year"].fillna(1990).astype(int)
roads["age"] = roads["install_year"].apply(compute_age)
roads["road_class"] = roads.apply(classify_road, axis=1)

defaults = {
    "ARTERIAL": {"expected_life": 40, "eta": 40, "k": 3.0, "unit_cost": 450},
    "COLLECTOR": {"expected_life": 35, "eta": 35, "k": 2.8, "unit_cost": 350},
    "LOCAL": {"expected_life": 30, "eta": 30, "k": 2.5, "unit_cost": 250},
}
roads["expected_life"] = roads["road_class"].apply(lambda x: defaults[x]["expected_life"])
roads["eta"] = roads["road_class"].apply(lambda x: defaults[x]["eta"])
roads["k"] = roads["road_class"].apply(lambda x: defaults[x]["k"])
roads["unit_cost"] = roads["road_class"].apply(lambda x: defaults[x]["unit_cost"])

roads["prob_failure"] = roads.apply(
    lambda r: weibull_failure_probability(r["age"], r["eta"], r["k"]),
    axis=1
)

roads["condition_class"] = roads["prob_failure"].apply(condition_class_from_probability)

roads = roads.to_crs(3857)
roads["length_m"] = roads.geometry.length
roads = roads.to_crs(4326)

roads["replacement_cost"] = roads.apply(
    lambda r: replacement_cost(r["length_m"], r["unit_cost"]),
    axis=1
)

import pandas as pd

# Drop non-essential / problematic columns
cols_to_drop = [
    "CREATION_DATE",
    "REVISION_DATE",
    "GEOMETRY_UPDATE_DATETIME",
    "EFFECTIVE_DATETIME",
    "ROAD_ABSOLUTE_ACCURACY",
    "ACQUISITION_TECHNIQUE",
    "EXIT_NUMBER",
    "TOLL_ROAD_IND",
    "FROM_JUNCTION_ID",
    "TO_JUNCTION_ID",
    "NATIONAL_UUID",
    "OGF_ID",
    "SHAPE_Length",
    "LENGTH"
]
roads = roads.drop(columns=cols_to_drop, errors="ignore")

# Convert any remaining datetime columns to strings
for col in roads.columns:
    if pd.api.types.is_datetime64_any_dtype(roads[col]):
        roads[col] = roads[col].astype(str)

# Ensure we have a projected length if not already
if "length_m" not in roads.columns:
    roads = roads.to_crs(3857)
    roads["length_m"] = roads.geometry.length
    roads = roads.to_crs(4326)

roads.dtypes

import json
import pandas as pd
from dash import Dash, dcc, html, Input, Output
import plotly.express as px

# Build Dash app
app = Dash(__name__)

app.layout = html.Div([
    html.H1("Ontario Road Network – AMP Dashboard", style={"textAlign": "center"}),

    html.Div([
        html.Div([
            html.H3("Total Length (km)"),
            html.H2(f"{roads['length_m'].sum() / 1000:.1f}")
        ]),
        html.Div([
            html.H3("Total Replacement Cost ($M)"),
            html.H2(f"{roads['replacement_cost'].sum() / 1e6:.2f}")
        ]),
        html.Div([
            html.H3("Average Age (years)"),
            html.H2(f"{roads['age'].mean():.1f}")
        ]),
        html.Div([
            html.H3("Poor Condition (4–5) (%)"),
            html.H2(f"{(roads['condition_class'] >= 4).mean() * 100:.1f}%")
        ]),
    ], style={"display": "flex", "justifyContent": "space-around"}),

    html.Br(),

    html.Div([
        html.Div([
            html.Label("Road Class"),
            dcc.Dropdown(
                options=[{"label": c, "value": c} for c in sorted(roads["road_class"].unique())],
                id="road-class-filter",
                multi=True
            )
        ], style={"width": "45%"}),

        html.Div([
            html.Label("Condition Class"),
            dcc.Dropdown(
                options=[{"label": str(c), "value": c} for c in sorted(roads["condition_class"].unique())],
                id="condition-filter",
                multi=True
            )
        ], style={"width": "45%"}),
    ], style={"display": "flex", "justifyContent": "space-between"}),

    html.Br(),

    dcc.Graph(id="map"),
    html.Br(),

    html.Div([
        dcc.Graph(id="condition-chart", style={"width": "48%"}),
        dcc.Graph(id="cost-chart", style={"width": "48%"}),
    ], style={"display": "flex", "justifyContent": "space-between"})
])

@app.callback(
    [Output("map", "figure"),
     Output("condition-chart", "figure"),
     Output("cost-chart", "figure")],
    [Input("road-class-filter", "value"),
     Input("condition-filter", "value")]
)
def update_dashboard(selected_classes, selected_conditions):
    df = roads.copy()

    if selected_classes:
        df = df[df["road_class"].isin(selected_classes)]
    if selected_conditions:
        df = df[df["condition_class"].isin(selected_conditions)]

    geojson = json.loads(df.to_json())

    fig_map = px.choropleth_mapbox(
        df,
        geojson=geojson,
        locations=df.index,
        color="condition_class",
        mapbox_style="carto-positron",
        zoom=5,
        center={"lat": 44.0, "lon": -79.5},
        opacity=0.7,
        color_continuous_scale=["green", "yellow", "orange", "red", "darkred"],
        hover_data={
            "install_year": True,
            "age": True,
            "prob_failure": True,
            "replacement_cost": True
        }
    )

    fig_condition = px.histogram(
        df,
        x="condition_class",
        nbins=5,
        title="Condition Class Distribution"
    )

    cost_df = df.groupby("condition_class")["replacement_cost"].sum().reset_index()
    fig_cost = px.bar(
        cost_df,
        x="condition_class",
        y="replacement_cost",
        title="Replacement Cost by Condition Class"
    )

    return fig_map, fig_condition, fig_cost

from pyngrok import ngrok

# Kill any existing tunnels
ngrok.kill()

# Start a new tunnel to port 8050
public_url = ngrok.connect(39mJIsI896k36NVUoWYxrQFzo6S_47XF8kH8prx4eVgJ84Ckg)
print("Dash app URL:", public_url)

app.run_server(host="0.0.0.0", port=8050, debug=False)

from pyngrok import ngrok
from google.colab import userdata

# Kill any existing tunnels
ngrok.kill()

# Get ngrok authtoken from Colab secrets
NGROK_AUTHTOKEN="39mJIsI896k36NVUoWYxrQFzo6S_47XF8kH8prx4eVgJ84Ckg" # Changed to use the secret name
ngrok.set_auth_token(NGROK_AUTHTOKEN)

# Start a new tunnel to port 8050
public_url = ngrok.connect(8050)
print("Dash app URL:", public_url)

app.run_server(host="0.0.0.0", port=8050, debug=False)

